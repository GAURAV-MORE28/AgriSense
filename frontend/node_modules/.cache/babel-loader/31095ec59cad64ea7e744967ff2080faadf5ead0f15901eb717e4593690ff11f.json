{"ast":null,"code":"/**\r\n * Offline Context - Manages offline state and sync queue\r\n */import React,{createContext,useContext,useState,useEffect}from'react';import{openDB}from'idb';import{jsx as _jsx}from\"react/jsx-runtime\";const OfflineContext=/*#__PURE__*/createContext(undefined);let db=null;async function getDB(){if(db)return db;db=await openDB('krishi-ai-db',1,{upgrade(database){if(!database.objectStoreNames.contains('profiles')){database.createObjectStore('profiles',{keyPath:'id'});}if(!database.objectStoreNames.contains('applications')){database.createObjectStore('applications',{keyPath:'id'});}if(!database.objectStoreNames.contains('syncQueue')){database.createObjectStore('syncQueue',{keyPath:'id'});}}});return db;}export const OfflineProvider=_ref=>{let{children}=_ref;const[isOffline,setIsOffline]=useState(!navigator.onLine);const[queuedCount,setQueuedCount]=useState(0);useEffect(()=>{const handleOnline=()=>setIsOffline(false);const handleOffline=()=>setIsOffline(true);window.addEventListener('online',handleOnline);window.addEventListener('offline',handleOffline);// Update queued count\nupdateQueuedCount();return()=>{window.removeEventListener('online',handleOnline);window.removeEventListener('offline',handleOffline);};},[]);const updateQueuedCount=async()=>{try{const database=await getDB();const count=await database.count('syncQueue');setQueuedCount(count);}catch(e){console.error('Failed to get queue count');}};const saveProfile=async(id,data)=>{const database=await getDB();await database.put('profiles',{id,data,synced:!isOffline,updatedAt:new Date().toISOString()});if(isOffline){await database.put('syncQueue',{id:\"profile-\".concat(id,\"-\").concat(Date.now()),type:'profile',operation:'update',data,createdAt:new Date().toISOString()});updateQueuedCount();}};const saveApplication=async(id,data)=>{const database=await getDB();await database.put('applications',{id,data,synced:!isOffline,createdAt:new Date().toISOString()});if(isOffline){await database.put('syncQueue',{id:\"app-\".concat(id,\"-\").concat(Date.now()),type:'application',operation:'create',data,createdAt:new Date().toISOString()});updateQueuedCount();}};const getProfile=async id=>{const database=await getDB();const result=await database.get('profiles',id);return(result===null||result===void 0?void 0:result.data)||null;};const syncPending=async()=>{if(isOffline)return;const database=await getDB();const queue=await database.getAll('syncQueue');for(const item of queue){try{// In production, send to server\nconsole.log('Syncing:',item);await database.delete('syncQueue',item.id);}catch(error){console.error('Sync failed for item:',item.id,error);}}updateQueuedCount();};// Auto-sync when coming back online\nuseEffect(()=>{if(!isOffline){syncPending();}},[isOffline]);return/*#__PURE__*/_jsx(OfflineContext.Provider,{value:{isOffline,queuedCount,saveProfile,saveApplication,getProfile,syncPending},children:children});};export const useOffline=()=>{const context=useContext(OfflineContext);if(context===undefined){throw new Error('useOffline must be used within an OfflineProvider');}return context;};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}